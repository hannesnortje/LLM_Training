<mxfile host="65bd71144e">
    <diagram name="Balanced Training Architecture" id="architecture">
        <mxGraphModel dx="2208" dy="948" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="2400" pageHeight="1800" math="0" shadow="0">
            <root>
                <mxCell id="0"/>
                <mxCell id="1" parent="0"/>
                <mxCell id="title" value="Web4 Balanced LoRA Training Architecture" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=32;fontStyle=1" parent="1" vertex="1">
                    <mxGeometry x="400" y="20" width="1600" height="50" as="geometry"/>
                </mxCell>
                <mxCell id="subtitle" value="RAG-First Pipeline: Train Patterns, Reference History, Swappable Tools | Target: 37K trained samples (~20M tokens) + 12K RAG tool samples from 534 PDCAs" style="text;html=1;strokeColor=none;fillColor=#E3F2FD;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=1;fontSize=16;fontStyle=2" parent="1" vertex="1">
                    <mxGeometry x="400" y="80" width="1600" height="35" as="geometry"/>
                </mxCell>
                <object label="&lt;font color=&quot;#1565C0&quot;&gt;🤖 BASE MODEL&lt;/font&gt;&#xa;&#xa;Qwen/Qwen2.5-Coder-7B-Instruct&#xa;(HuggingFace - Full Precision)&#xa;&#xa;For Inference: qwen2.5-coder:7b-instruct-q4_K_M" tooltip="The base model is Qwen2.5-Coder 7B Instruct, chosen for its strong code generation capabilities and 7 billion parameters optimized for coding tasks. Training uses the full precision model from HuggingFace to maximize learning quality during LoRA fine-tuning. After training, the adapter is merged with the base model and quantized to Q4_K_M format for deployment via Ollama. This quantization reduces model size from 14GB to 4GB while maintaining 95 percent quality, enabling fast inference on M1 Mac hardware with 32GB RAM and MPS backend. The model architecture includes 28 transformer layers, 4096 hidden dimensions, 32 attention heads, 32768 context window, and supports 100+ programming languages with particular strength in Python, TypeScript, JavaScript, Java, and C++. The base model already understands general programming concepts like OOP, error handling, testing, and documentation - the LoRA fine-tuning teaches it Web4-specific conventions like 5-layer architecture, Radical OOP, empty constructor pattern, scenario-based state management, Vitest testing framework, and PDCA methodology for continuous improvement." id="base-model">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#BBDEFB;strokeColor=#1565C0;strokeWidth=4;fontSize=14;fontStyle=1;verticalAlign=top;spacingTop=15;" parent="1" vertex="1">
                        <mxGeometry x="900" y="150" width="600" height="140" as="geometry"/>
                    </mxCell>
                </object>
                <object label="&lt;font color=&quot;#2E7D32&quot;&gt;🎯 LORA ADAPTER (Trained Knowledge)&lt;/font&gt;&#xa;&#xa;37,000 samples (~20M tokens)&#xa;Patterns &amp; Methodology (95% Web4, 3% tools, 2% guardrails)&#xa;r=16, alpha=32, dropout=0.05&#xa;Training: 8-11 hours on M1 Mac" tooltip="The LoRA adapter is a small trainable module (approximately 80MB, reduced from 100MB) that learns Web4-specific patterns without modifying the base model. LoRA uses rank decomposition to create two small matrices for each transformer layer, where rank r=16 means each matrix is much smaller than the original weight matrix. Training only these small matrices is 1000x faster and uses 10x less memory than full fine-tuning, enabling training on consumer hardware. The adapter contains 37,000 training samples totaling approximately 20M tokens (reduced from 46K/25M), carefully curated to teach Web4 methodology with optimal token efficiency: 95 percent Web4-specific patterns versus 74 percent in the old approach. Process Knowledge (5K samples) covering PDCA structure, TRON format, CMM1-4 framework, dual link format, and 12-step startup protocol. Code Patterns (18K samples) including empty constructor pattern, init method for scenario-based state, toScenario serialization, 5-layer architecture, and Radical OOP. Extracted PDCA Patterns (8K samples) with problem-solution pairs, debugging methodologies, architectural decisions, violation fixes, integration patterns, and collaboration patterns. Representative PDCAs (3K samples) from top 200-300 complete PDCAs selected by quality score. Generic Tool Awareness (1K samples, NEW) teaching the CONCEPT of tools with JSON structure and parameter passing, NOT specific IDE implementations. Guardrails (2K samples) for security violations and framework compliance. Training takes 8-11 hours on M1 Mac with MPS acceleration (20 percent faster due to reduced token count), monitoring loss convergence to 0.6-1.0 plateau and memory usage staying under 28GB." id="lora-adapter">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#C8E6C9;strokeColor=#2E7D32;strokeWidth=4;fontSize=14;fontStyle=1;verticalAlign=top;spacingTop=15;" parent="1" vertex="1">
                        <mxGeometry x="900" y="320" width="600" height="140" as="geometry"/>
                    </mxCell>
                </object>
                <object label="&lt;font color=&quot;#F57F17&quot;&gt;🗄️ THREE-TIER RAG ARCHITECTURE&lt;/font&gt;&#xa;&#xa;Tier 1: ChromaDB (Semantic Search)&#xa;Tier 2: Redis Graph (Breadcrumb Navigation)&#xa;Tier 3: SQLite (Temporal Queries)&#xa;&#xa;534 PDCAs → ~2,670 chunks | All components indexed" tooltip="The three-tier RAG architecture is the cornerstone of the balanced training strategy, serving as both the data source for training sample generation and the runtime historical reference library. This hybrid design optimizes different query patterns: Tier 1 ChromaDB provides semantic search using vector embeddings, ideal for finding similar PDCAs or patterns. The 534 historical PDCAs are chunked into approximately 2,670 semantically complete chunks using PDCA-aware adaptive chunking that preserves document structure by splitting on section boundaries. Each chunk includes 15+ metadata fields covering temporal data, agent context, work context, task context, CMM compliance, and quality signals. Tier 2 Redis Graph stores breadcrumb navigation links between PDCAs, enabling fast graph traversal to implement the read-to-depth-3 principle. Graph queries are 50x faster than vector search for adjacency relationships. Tier 3 SQLite handles temporal queries efficiently, supporting fast date-range lookups and agent timeline tracking without scanning the entire vector database. This three-tier design provides single source of truth for all training data, intelligent sampling via semantic queries, natural deduplication through chunking, metadata-driven filtering, graph-aware context expansion, incremental refinement, and consistent methodology." id="rag-architecture">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#FFF9C4;strokeColor=#F57F17;strokeWidth=4;fontSize=14;fontStyle=1;verticalAlign=top;spacingTop=15;" parent="1" vertex="1">
                        <mxGeometry x="50" y="150" width="750" height="480" as="geometry"/>
                    </mxCell>
                </object>
                <object label="&lt;font color=&quot;#E65100&quot;&gt;Tier 1: ChromaDB&lt;/font&gt;&#xa;Vector Embeddings&#xa;~2,670 PDCA chunks&#xa;15+ metadata fields&#xa;Semantic similarity search" tooltip="ChromaDB is an open-source vector database optimized for semantic search using embeddings. Each PDCA chunk is converted to a 768-dimensional vector using a sentence-transformer model, capturing semantic meaning beyond keyword matching. This enables queries to find relevant PDCAs even if they use different terminology. The chunks are stored with comprehensive metadata enabling filtered queries. ChromaDB uses HNSW index for fast approximate nearest neighbor search, returning results in approximately 500ms. The metadata fields enable precise filtering by chunk type, CMM level, task type, date, agent, and verification status. ChromaDB also indexes 3,477 TypeScript component files by layer and pattern, plus 238 process documents by role. During training sample generation, ChromaDB is queried thousands of times to extract patterns for the training dataset." id="chromadb">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#FFE0B2;strokeColor=#EF6C00;strokeWidth=2;fontSize=11;fontStyle=0;" parent="1" vertex="1">
                        <mxGeometry x="70" y="320" width="220" height="90" as="geometry"/>
                    </mxCell>
                </object>
                <object label="&lt;font color=&quot;#E65100&quot;&gt;Tier 2: Redis Graph&lt;/font&gt;&#xa;Breadcrumb links&#xa;534 nodes, PRECEDES edges&#xa;Fast graph traversal&#xa;Read to depth 3" tooltip="Redis Graph stores PDCA breadcrumb relationships as a graph database, enabling fast traversal of prev/next links extracted from PDCA metadata. Each of the 534 PDCAs becomes a node with properties, and PRECEDES edges connect chronologically related PDCAs. Graph queries are extremely fast (approximately 10ms) compared to vector search (approximately 500ms) because they use index lookups rather than similarity computation. The primary use case is read-to-depth-3: when semantic search finds a relevant PDCA, walk the graph backward and forward up to 3 levels deep to understand the full context. This implements the Web4 principle that context matters - a single PDCA in isolation may miss important background. Redis Graph uses sparse adjacency matrices for efficient traversal and supports Cypher-like query language. During training sample generation, graph expansion enriches semantic search results to include predecessor and successor context." id="redis-graph">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#FFE0B2;strokeColor=#EF6C00;strokeWidth=2;fontSize=11;fontStyle=0;" parent="1" vertex="1">
                        <mxGeometry x="310" y="320" width="220" height="90" as="geometry"/>
                    </mxCell>
                </object>
                <object label="&lt;font color=&quot;#E65100&quot;&gt;Tier 3: SQLite&lt;/font&gt;&#xa;Temporal metadata&#xa;Fast date-range queries&#xa;Agent/sprint aggregation&#xa;5ms query time" tooltip="SQLite stores temporal and categorical metadata in a relational schema optimized for fast date-range queries, agent timelines, and sprint aggregations. The pdca_timeline table contains pdca_id, timestamp, session, agent_name, agent_role, branch, sprint, cmm_level, and objective with appropriate indexes. Indexes enable sub-5ms queries which is 100x faster than scanning ChromaDB with metadata filters because SQL databases are optimized for structured queries with B-tree indexes. SQLite is also used for analytics: count PDCAs per day, identify most active agents, track CMM level distribution over time, measure sprint velocity. During training sample generation, temporal queries ensure diverse time period coverage to prevent temporal bias where the model only learns the newest patterns. SQLite is lightweight, requires no server, and integrates easily with Python. The three-tier design uses each database for its strength: ChromaDB for semantic understanding, Redis Graph for relationship traversal, SQLite for structured queries." id="sqlite">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#FFE0B2;strokeColor=#EF6C00;strokeWidth=2;fontSize=11;fontStyle=0;" parent="1" vertex="1">
                        <mxGeometry x="560" y="320" width="220" height="90" as="geometry"/>
                    </mxCell>
                </object>
                <object label="&lt;font color=&quot;#E65100&quot;&gt;📚 Collections&lt;/font&gt;&#xa;&#xa;• pdca_historical (534)&#xa;• components (3,477)&#xa;• process_docs (238)&#xa;• tool_examples (12K) ★ NEW&#xa;• daily_buffer (transient)" tooltip="The RAG system organizes data into five ChromaDB collections. The pdca_historical collection contains 534 PDCAs as approximately 2,670 chunks - this is the permanent reference library with all historical PDCAs indexed with PDCA-aware adaptive chunking and comprehensive metadata. This collection never clears. The components collection indexes 3,477 TypeScript files organized by layer and pattern. The process_docs collection contains 238 documents including role-specific process documentation, CMM framework guides, PDCA templates, creation guides, decision frameworks, and compliance checklists. The tool_examples collection (NEW) stores 12,000 IDE-specific tool examples (10K Continue tools plus 2K negative examples) with metadata including tool_name, tool_ecosystem, tool_version, usage_pattern, and context_type. These tool examples are NOT trained into the LoRA adapter but are retrieved at runtime and injected into the context when the model needs to make tool calls. This enables IDE flexibility - switching from Continue to Cursor takes 5 minutes (clear Continue tools, index Cursor tools) versus 10-14 hours full retraining. The tool examples are swappable by ecosystem and support multiple IDEs simultaneously. The daily_buffer collection holds today work-in-progress and is transient, cleared nightly. During the evening training loop, daily_buffer is queried for untrained patterns, those patterns are trained into the adapter, and the buffer is cleared after moving data to permanent collections. This implements the incremental learning strategy where the model continuously improves from daily work." id="collections">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#FFE0B2;strokeColor=#EF6C00;strokeWidth=2;fontSize=11;fontStyle=0;" parent="1" vertex="1">
                        <mxGeometry x="70" y="440" width="700" height="130" as="geometry"/>
                    </mxCell>
                </object>
                <mxCell id="arrow-rag-to-training" value="" style="endArrow=classic;html=1;rounded=0;strokeWidth=4;strokeColor=#F57F17;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="rag-architecture" target="lora-adapter" edge="1">
                    <mxGeometry width="50" height="50" relative="1" as="geometry">
                        <mxPoint x="800" y="400" as="sourcePoint"/>
                        <mxPoint x="850" y="350" as="targetPoint"/>
                    </mxGeometry>
                </mxCell>
                <mxCell id="arrow-label-training" value="RAG-Driven&#xa;Sample Generation&#xa;37K samples" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontSize=12;fontStyle=1;fontColor=#F57F17;fillColor=#FFF8E1;strokeColor=#F9A825;rounded=1;" parent="arrow-rag-to-training" vertex="1" connectable="0">
                    <mxGeometry x="-0.1" y="2" relative="1" as="geometry">
                        <mxPoint x="5" as="offset"/>
                    </mxGeometry>
                </mxCell>
                <object label="&lt;font color=&quot;#4A148C&quot;&gt;📦 TRAINING DATA BUCKETS (37K trained + 12K RAG tools)&lt;/font&gt;" tooltip="Training data is organized into 8 trained buckets plus RAG tool repository, teaching the model HOW TO CODE, HOW TO WORK, HOW TO SOLVE PROBLEMS, and WHAT NOT TO DO. The hybrid tool architecture splits tool knowledge: 1K generic tool awareness is trained (teaches CONCEPT of tools) while 12K IDE-specific examples stay in RAG (enables IDE switching without retraining). The trained buckets teach: HOW TO CODE - style_core (12K samples, 32 percent) extracts real Web4 architectural patterns from 3,477 TypeScript files including empty constructor, 5-layer architecture, Radical OOP, scenario-based state management. style_refactor (3K samples, 8 percent) shows code evolution and continuous improvement patterns. HOW TO WORK - process_framework (5K samples, 13 percent) teaches PDCA structure v3.2.4.2, TRON decision format, CMM1-4 progression, dual link format, 12-step startup protocol, verification checklists, and 50+ key behavioral lessons. HOW TO SOLVE PROBLEMS - domain_patterns (8K samples, 22 percent) extracts distilled problem-solving patterns from all 534 PDCAs including debugging methodologies, architectural decisions, integration patterns, and collaboration patterns. domain_representatives (3K samples, 8 percent) provides complete exemplary PDCAs selected by quality scoring to show end-to-end work structure. WHAT NOT TO DO - guardrails (2K samples, 5 percent) teaches security violations, Jest ban enforcement, manual operation prevention, and framework compliance. tool_awareness (1K samples, 3 percent) teaches generic tool-calling concepts with JSON structure and parameter passing, IDE-agnostic. eval (2K samples, 5 percent) is held-out test set NEVER trained. The RAG Tool Repository stores 12K IDE-specific tool examples with metadata for runtime injection, enabling 5-minute IDE switching versus 10-14 hours retraining." id="training-buckets">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#F3E5F5;strokeColor=#6A1B9A;strokeWidth=3;fontSize=14;fontStyle=1;verticalAlign=top;spacingTop=15;" parent="1" vertex="1">
                        <mxGeometry x="1580" y="150" width="770" height="310" as="geometry"/>
                    </mxCell>
                </object>
                <object label="TRAINED (37K samples):&#xa;&#xa;HOW TO CODE: style_core 12K (32%) | style_refactor 3K (8%)&#xa;HOW TO WORK: process_framework 5K (13%)&#xa;HOW TO SOLVE: domain_patterns 8K (22%) | domain_representatives 3K (8%)&#xa;WHAT NOT TO DO: guardrails 2K (5%) | tool_awareness 1K (3%)&#xa;EVALUATION: eval 2K (5%) - HOLD-OUT&#xa;&#xa;RAG TOOLS (12K): tool_core 10K + tool_neg 2K (swappable)" tooltip="Clearer bucket naming that reflects what we actually teach the model. TRAINED samples (37K total, approximately 20M tokens): HOW TO CODE (15K samples, 40 percent) - style_core 12K samples teaches real Web4 architectural patterns from 3,477 TypeScript files: empty constructor pattern, 5-layer architecture, Radical OOP, scenario-based state management, init methods, toScenario serialization, component structure, and Vitest testing. style_refactor 3K samples shows code evolution patterns: CMM2 to CMM3 transformations, technical debt reduction, pattern application, refactoring journeys, and continuous improvement mindset. HOW TO WORK (5K samples, 13 percent) - process_framework 5K samples teaches the methodology: PDCA structure v3.2.4.2, TRON decision format, CMM1-4 progression and compliance, dual link format, 12-step startup protocol, verification checklists, collaboration patterns, feedback point recognition, and 50+ key behavioral lessons from trainAI. HOW TO SOLVE PROBLEMS (11K samples, 30 percent) - domain_patterns 8K samples extracts distilled problem-solving patterns from all 534 historical PDCAs: debugging methodologies, architectural decisions, violation fixes, integration patterns, collaboration patterns, and problem-solution pairs that capture Web4 domain wisdom. domain_representatives 3K samples provides complete exemplary PDCAs selected by quality scoring to show end-to-end work structure and full PDCA methodology in action. WHAT NOT TO DO (3K samples, 8 percent) - guardrails 2K samples teaches compliance: Jest ban enforcement, manual operation prevention, security violations, framework violations. tool_awareness 1K samples teaches generic tool-calling concepts: JSON structure, parameter passing, context awareness, IDE-agnostic patterns. EVALUATION (2K samples, 5 percent) - eval 2K samples is held-out test set stratified across all categories, NEVER trained, used for unbiased quality measurement. RAG TOOLS (12K samples, approximately 3.5MB): NOT trained into LoRA. Continue tools 10K plus negatives 2K stored in ChromaDB tool_examples collection with metadata. Runtime injection adds approximately 150ms latency but enables 5-minute IDE switching versus 10-14 hour retraining." id="bucket-detail">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#E1BEE7;strokeColor=#7B1FA2;strokeWidth=2;fontSize=11;fontStyle=0;" parent="1" vertex="1">
                        <mxGeometry x="1600" y="200" width="730" height="120" as="geometry"/>
                    </mxCell>
                </object>
                <object label="&lt;font color=&quot;#6A1B9A&quot;&gt;Token Distribution: ~20M trained + 3.5MB RAG tools&lt;/font&gt;&#xa;Avg 540 tokens/sample | 95% Web4, 3% tools, 2% guardrails&#xa;Optimized for M1 Mac (32GB RAM)&#xa;Training time: 8-11 hours (20% faster)" tooltip="The approximately 20M token budget is optimized for M1 Mac hardware with improved token efficiency. Token calculation: 37K samples times 540 average tokens per sample equals approximately 20M tokens, reduced from 25M (saving 5M tokens or 20 percent). The 540 token average accounts for short samples (100-200 tokens) for simple patterns, medium samples (400-800 tokens) for complete class implementations, and long samples (1200-1800 tokens) for full PDCA documents. This 20M token count enables faster training (8-11 hours versus 10-14 hours) while maintaining quality. Token distribution optimization: 95 percent Web4-specific patterns (versus 74 percent in old approach), 3 percent generic tool awareness (versus 22 percent for full tool training), 2 percent guardrails. This increases Web4 focus by 28 percent while maintaining tool capabilities through runtime RAG injection. The RAG tool repository stores 12K tool examples as approximately 3.5MB of text data, retrieved at runtime with approximately 150ms latency. Token efficiency strategies include PDCA patterns being distilled to save 60 percent tokens, code patterns using targeted extracts to save 40 percent tokens, representatives using smart variations to save 70 percent tokens, and tool examples staying in RAG to save 9K training samples. The 20M budget enables training sophisticated Web4 behaviors including 5-layer OOP architecture, empty constructor pattern, scenario-based state management, PDCA methodology with TRON format, CMM compliance, and framework adherence." id="token-dist">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#E1BEE7;strokeColor=#7B1FA2;strokeWidth=2;fontSize=11;fontStyle=0;" parent="1" vertex="1">
                        <mxGeometry x="1600" y="340" width="730" height="100" as="geometry"/>
                    </mxCell>
                </object>
                <mxCell id="arrow-training" value="" style="endArrow=classic;html=1;rounded=0;strokeWidth=4;strokeColor=#2E7D32;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="lora-adapter" target="trained-model" edge="1">
                    <mxGeometry width="50" height="50" relative="1" as="geometry">
                        <mxPoint x="1200" y="500" as="sourcePoint"/>
                        <mxPoint x="1200" y="600" as="targetPoint"/>
                    </mxGeometry>
                </mxCell>
                <mxCell id="arrow-label-lora" value="LoRA Training&lt;br&gt;8-11 hours&lt;br&gt;M1 Mac MPS" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontSize=12;fontStyle=1;fontColor=#2E7D32;fillColor=#E8F5E9;strokeColor=#43A047;rounded=1;" parent="arrow-training" vertex="1" connectable="0">
                    <mxGeometry x="-0.1" y="2" relative="1" as="geometry">
                        <mxPoint x="-62" as="offset"/>
                    </mxGeometry>
                </mxCell>
                <object label="&lt;font color=&quot;#1565C0&quot;&gt;🎓 TRAINED MODEL&lt;/font&gt;&#xa;&#xa;Base + LoRA Adapter&#xa;Merged &amp; Quantized (Q4_K_M)&#xa;Deployed to Ollama&#xa;web4-agent:latest" tooltip="The trained model is the final production artifact combining the base model general coding knowledge with the LoRA adapter Web4-specific patterns. Post-training process: merge LoRA adapter weights with base model weights, quantize merged model from FP16 to Q4_K_M format (4-bit with higher precision for critical attention layers), convert to GGUF format for optimized inference, create Ollama modelfile, and import to Ollama. The trained model capabilities include pattern recognition, code generation, PDCA creation, refactoring, guardrails, and collaboration. The 4GB quantized model loads in approximately 3 seconds on M1 Mac, generates at approximately 20 tokens per second, and achieves 90 percent accuracy on evaluation set metrics including pattern recognition 95 percent, PDCA template 95 percent, TRON format 90 percent, empty constructor 95 percent, CMM understanding 90 percent, historical retrieval 85 percent, refusal accuracy 98 percent, and overall score 90 percent." id="trained-model">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#E3F2FD;strokeColor=#1565C0;strokeWidth=4;fontSize=14;fontStyle=1;verticalAlign=top;spacingTop=15;" parent="1" vertex="1">
                        <mxGeometry x="900" y="550" width="600" height="140" as="geometry"/>
                    </mxCell>
                </object>
                <mxCell id="arrow-runtime-rag" value="" style="endArrow=classic;startArrow=classic;html=1;rounded=0;strokeWidth=3;strokeColor=#FF6F00;exitX=0;exitY=0.75;exitDx=0;exitDy=0;entryX=1;entryY=0.75;entryDx=0;entryDy=0;dashed=1;" parent="1" source="trained-model" target="rag-architecture" edge="1">
                    <mxGeometry width="50" height="50" relative="1" as="geometry">
                        <mxPoint x="700" y="650" as="sourcePoint"/>
                        <mxPoint x="750" y="600" as="targetPoint"/>
                    </mxGeometry>
                </mxCell>
                <mxCell id="arrow-label-runtime" value="Runtime Queries&#xa;(10-20% PDCA history)&#xa;(30% tool injection)" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontSize=11;fontStyle=1;fontColor=#FF6F00;fillColor=#FFF3E0;strokeColor=#FB8C00;rounded=1;" parent="arrow-runtime-rag" vertex="1" connectable="0">
                    <mxGeometry x="-0.05" y="1" relative="1" as="geometry">
                        <mxPoint y="-30" as="offset"/>
                    </mxGeometry>
                </mxCell>
                <object label="&lt;font color=&quot;#D84315&quot;&gt;🌙 EVENING TRAINING LOOP&lt;/font&gt;&#xa;&#xa;Daily Buffer → Query Untrained → Generate Samples&#xa;→ Incremental Training (1 epoch) → Mark as Trained&#xa;→ Move to Historical → Clear Buffer&#xa;&#xa;Scheduled: 10 PM daily | Duration: 2-3 hours" tooltip="The evening training loop implements continuous learning, automatically incorporating each day work into the model every night at 10 PM. This creates a virtuous cycle where the model improves daily from real project work. The 7-step nightly process: Daily Buffer Collection throughout the day with new PDCAs indexed into daily_buffer with metadata. Query Untrained Patterns at 10 PM to identify what is new since yesterday. Generate Incremental Samples extracting patterns from today work with quality scoring. Incremental LoRA Training for these new samples for 1 epoch with adjusted hyperparameters, taking 2-3 hours for typical 50-sample daily batch. Mark as Trained updating RAG metadata for all trained chunks. Move to Historical with PDCAs from daily_buffer moved to pdca_historical collection and Redis Graph updated with new PRECEDES edges. Clear Daily Buffer with the collection archived and system reset for tomorrow. The evening loop advantages include continuous improvement, pattern discovery, adaptation, efficiency, and metadata-driven smart querying. Evening loop monitoring includes daily logs tracking sample count, training loss, memory usage, and completion time with alerting for issues." id="evening-loop">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#FFCCBC;strokeColor=#D84315;strokeWidth=4;fontSize=13;fontStyle=1;verticalAlign=top;spacingTop=15;" parent="1" vertex="1">
                        <mxGeometry x="50" y="690" width="750" height="210" as="geometry"/>
                    </mxCell>
                </object>
                <object label="&lt;font color=&quot;#1B5E20&quot;&gt;🚀 PRODUCTION DEPLOYMENT&lt;/font&gt;&#xa;&#xa;Ollama Model: web4-agent:latest&#xa;Fast Inference: ~20 tokens/sec on M1&#xa;Memory: ~4GB loaded&#xa;Response: 80-90% from training, 10-20% with RAG&#xa;Latency: under 200ms (trained), ~500ms (with RAG)" tooltip="Production deployment architecture optimizes for fast, reliable inference while maintaining access to historical context when needed. Ollama Integration provides REST API for LLM queries, chat interface for interactive sessions, and embedding endpoint for RAG similarity search. Ollama handles model lifecycle, request batching, and response streaming. Performance Characteristics include fast inference at approximately 20 tokens per second on M1 Mac, low memory footprint of approximately 4GB loaded, quick cold start of approximately 3 seconds to load model, and sub-200ms response latency for trained knowledge queries not requiring RAG. Decision Logic for RAG: the model first attempts to answer from trained knowledge (80-90 percent of queries), and for queries requiring specific historical context, the model queries RAG (10-20 percent of queries). RAG augmentation adds approximately 300ms latency but provides accurate historical reference. Hybrid Response Generation retrieves 3-5 relevant chunks, formats retrieved context, generates response incorporating both trained knowledge and retrieved facts, and includes source citations for traceability. Monitoring and Observability tracks response time metrics, RAG hit rate, quality metrics, and user feedback. Error handling gracefully degrades if RAG is unavailable, times out slow RAG queries, caches frequently accessed PDCAs, and logs all errors for analysis." id="production">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#C8E6C9;strokeColor=#2E7D32;strokeWidth=4;fontSize=13;fontStyle=1;verticalAlign=top;spacingTop=15;" parent="1" vertex="1">
                        <mxGeometry x="1580" y="550" width="770" height="210" as="geometry"/>
                    </mxCell>
                </object>
                <object label="&lt;font color=&quot;#01579B&quot;&gt;📊 KEY SUCCESS METRICS&lt;/font&gt;&#xa;&#xa;Training: Loss 0.6-1.0 | Memory under 28GB | 37K samples | ~20M tokens | 8-11 hrs&#xa;Quality: Pattern Recognition ≥95% | PDCA Template ≥95% | Framework Compliance ≥95%&#xa;Production: Response under 200ms | PDCA Queries 10-20% | Tool Queries 30% | Compilation ≥90% | Refusal ≥98%" tooltip="Key Success Metrics define measurable targets across three phases with hybrid tool architecture. Training Success includes loss convergence to 0.6-1.0 range indicating good learning, memory usage staying under 28GB ensuring stable training, successfully training 37K samples (down from 46K) in 8-11 hours (20 percent faster) validating the optimized token budget, and gradient norms staying stable confirming proper learning. Quality Success includes Pattern Recognition at least 95 percent measuring whether the model correctly identifies when to apply Web4 patterns, PDCA Template at least 95 percent evaluating generated PDCAs for completeness and compliance, Framework Compliance at least 95 percent checking generated code for proper architecture and conventions, Empty Constructor at least 95 percent for pattern adherence, CMM Understanding at least 90 percent for framework knowledge, Historical Retrieval at least 85 percent for RAG integration, and Refusal Accuracy at least 98 percent for guardrail effectiveness. Production Success includes response latency under 200ms for trained knowledge queries (no RAG), PDCA History Queries 10-20 percent of total requests validating historical reference usage, Tool Queries 30 percent of requests requiring tool example injection from RAG, Tool Injection Latency approximately 150ms additional for tool queries, Compilation Success at least 90 percent measuring whether generated code compiles on first attempt, and IDE Switching Time 5 minutes to swap Continue for Cursor versus 10-14 hours retraining. These metrics are continuously monitored via automated evaluation pipeline with alerting if any metric drops below threshold." id="metrics">
                    <mxCell style="rounded=1;whiteSpace=wrap;html=1;fillColor=#E1F5FE;strokeColor=#0277BD;strokeWidth=3;fontSize=12;fontStyle=1;verticalAlign=top;spacingTop=15;" parent="1" vertex="1">
                        <mxGeometry x="50" y="950" width="2300" height="110" as="geometry"/>
                    </mxCell>
                </object>
                <mxCell id="footer" value="🎯 Hybrid Tool Architecture: Train patterns + methodology (37K samples, ~20M tokens, 95% Web4) | 12K tool examples in RAG (swappable) | Reference history (534 PDCAs) | Learn continuously (evening loop) | 5-min IDE switching vs 10-14hr retraining" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#FFF9C4;strokeColor=#F57F17;strokeWidth=3;align=center;verticalAlign=middle;fontSize=13;fontStyle=1" parent="1" vertex="1">
                    <mxGeometry x="50" y="1090" width="2300" height="60" as="geometry"/>
                </mxCell>
            </root>
        </mxGraphModel>
    </diagram>
</mxfile>